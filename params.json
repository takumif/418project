{
  "name": "Parallelized Shakashaka Solver",
  "tagline": "15-418 Final Project by Vui Chee Siew and Takumi Fujimoto",
  "body": "## Project Checkpoint\r\n### Revised Schedule\r\n* Week 1: Implement the UI for the board\r\n* Week 2: Implement an efficient sequential solution\r\n* Week 3: Start implementing the parallel algorithm using Web Workers (Takumi), algorithm improvements (Vui Chee)\r\n* Week 3.5: Work on completing the parallel implementation (Takumi and Vui Chee)\r\n* Week 4: Tweak the work distribution among Web Workers (Takumi), make the tasks themselves efficient by identifying the bottleneck (Vui Chee)\r\n* Week 4.5: Modify the UI to display the performances of implementations (Takumi), test the implementations for correctness (Vui Chee)\r\n* Week 5: Prepare the presentation and final report (Takumi and Vui Chee)\r\n\r\n### Goals and Deliverables\r\nSince we currently don't have a working parallel implementation yet, our evaluation of how achievable the goals listed below are hasn't changed. However, since our sequential implementation is slower than we had anticipated, unless we make great improvements to its algorithm, the size limit of the boards that we can practically solve will be smaller than anticipated. Our plans for the demo haven't changed since the proposal.\r\n\r\n\r\n## Project Proposal\r\n### Summary\r\nWe will write an efficient, parallel shakashaka solver using JavaScript Web Workers, and compare its performance against that of a sequential implementation.\r\n\r\n### Background\r\n[Shakashaka](https://en.wikipedia.org/wiki/Shakashaka) is a logic puzzle, in which you fill a grid of squares with triangles to form rectangles. It is somewhat similar to nonograms in nature, and is known to be NP-complete. \r\n\r\nJavaScript [Web Workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers) allow us to run multithreaded code in the browser.\r\n\r\n#### Rules of Shakashakaã€€\r\n\r\n![](http://1.bp.blogspot.com/-D6Kxz3J51q8/TtpOtaO1KrI/AAAAAAAAATk/u35eNqONGlg/s1600/Shakashaka+Example.png)\r\n([image source](http://puzzleparasite.blogspot.com/2011/12/rules-shakashaka.html))\r\n\r\nEach white square can be filled by at most one black triangle and each triangle can 4 possible orientations. As for the black squares, the black square with a number on it indicate the number of black triangles that must be adjacent to the black square with the number on it. When I say adjacent, I mean that the black triangle shares a side with the black square with number. For those black squares without any numbers written, any number of black triangles can be adjacent to it. \r\n\r\nNow how to win this puzzle, the aim is to add black triangles validly and to form white rectangles such that all white shapes seen are rectangles. (White squares are considered as rectangles if you are unclear.)\r\n\r\n#### How do we solve it?\r\n\r\nWe have a board of a fixed and finite size. We will start filling the empty squares with triangles, and check if we have not reached an invalid configuration (i.e. there are white spaces that cannot form a rectangle). If the configuration is invalid, we will backtrack and try other configurations until a solved configuration appears. Of course, we can improve this algorithm by logically eliminating (and skipping the execution of) some of the configurations that will never lead to a solution. We will parallelize this traversal of the \"tree\" of configurations by having different workers validating configurations and discovering new potentially valid configurations.\r\n\r\n### Challenges\r\nWe are traversing a tree of possible grid configurations that spreads exponentially. We will need to figure out an efficient way to distribute the work among the workers (so that as many workers as possible are working at any given time) while not taking up too much memory. To be efficient with memory, we will need to think of an efficient way to duplicate data when we're going down multiple branches (for different configurations of moves). We will also need to determine what we parallelize across (e.g. can we/should we parallelize the validation of a single grid configuration?), and the bottleneck of the algorithm.\r\n\r\n### Resources\r\nWe will write the code from scratch. We will refer to [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers) regarding Web Workers.\r\n\r\n### Goals and deliverables\r\nPlanning to achieve:\r\n* At this point, it is unclear to us how much of the algorithm will be parallelizable (since we will try many variations of the algorithm). However, our current plan is to get a 2x speedup over sequential code using a quad-core CPU, which is similar to the improvements we've seen in the assignments we worked on earlier this semester.\r\n* We will be able to do an in-browser demo in which the solver solves a shakashaka puzzle using both the parallel and sequential implementations, and displays the speedup from parallelization.\r\n\r\nHoping to achieve:\r\n* We hope to achieve a 3x speedup over sequential implementation on a quad-core CPU.\r\n\r\n### Platform of choice\r\nWe chose JavaScript for the following reasons:\r\n* JavaScript is generally considered \"slow\", so it has a lot to gain from parallelization\r\n* Having a GUI (HTML page) makes entering and seeing shakashaka grids easier, which makes our app useful\r\n* We wanted to learn how to use and experiment with Web Workers\r\n \r\n ",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}