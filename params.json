{
  "name": "Parallelized Shakashaka Solver",
  "tagline": "15-418 Final Project by Vui Chee Siew and Takumi Fujimoto",
  "body": "## Project Proposal\r\n### Summary\r\nWe will write an efficient, parallel shakashaka solver using JavaScript Web Workers, and compare it against a sequential implementation.\r\n\r\n### Background\r\n[Shakashaka](https://en.wikipedia.org/wiki/Shakashaka) is a logic puzzle, in which you fill a grid of squares with triangles to form rectangles. It is similar to nonograms in concept, and is known to be NP-complete. \r\n\r\nJavaScript [Web Workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers) allow us to run multithreaded code in the browser.\r\n\r\n#### Rules of Shakashakaã€€\r\n\r\n![](http://1.bp.blogspot.com/-D6Kxz3J51q8/TtpOtaO1KrI/AAAAAAAAATk/u35eNqONGlg/s1600/Shakashaka+Example.png)\r\n([image source](http://takumif.github.io/shakashaka_solver/))\r\n\r\nEach white square can be filled by at most one black triangle and each triangle can 4 possible orientations. As for the black squares, the black square with a number on it indicate the number of black triangles that must be adjacent to the black square with the number on it. When I say adjacent, I mean that the black triangle shares a side with the black square with number. For those black squares without any numbers written, any number of black triangles can be adjacent to it. \r\n\r\nNow how to win this puzzle, the aim is to add black triangles validly and to form white rectangles such that all white shapes seen are rectangles. (White squares are considered as rectangles if you are unclear.)\r\n\r\n#### How do we solve it?\r\n\r\nWe have a board of a fixed and finite size. We will start filling the empty squares with triangles, and check if we have not reached an invalid configuration (i.e. there are white spaces that cannot form a rectangle). If the configuration is invalid, we will backtrack and try other configurations until a solved configuration appears. Of course, we can improve this algorithm by logically eliminating (and skipping the execution of) some of the configurations that will never lead to a solution. We will parallelize this traversal of the \"tree\" of configurations by having different workers validating configurations and discovering new potentially valid configurations.\r\n\r\n### Challenges\r\nWe are traversing a tree of possible grid configurations that spreads exponentially. We will need to figure out an efficient way to distribute the work among the workers (so that as many workers as possible are working at any given time) while not taking up too much memory. To be efficient with memory, we will need to think of an efficient way to duplicate data when we're going down multiple branches (for different configurations of moves). We will also need to determine what we parallelize across, and the bottleneck of the algorithm.\r\n\r\n### Resources\r\nWe will write the code from scratch. We will refer to [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers) regarding Web Workers.\r\n\r\n### Goals and deliverables\r\nlol\r\n\r\n### Platform of choice\r\nWe chose JavaScript for the following reasons:\r\n* JavaScript is generally considered \"slow\", so it has a lot to gain from parallelization\r\n* Having a GUI (HTML page) makes entering and seeing grid configurations easier, which makes our app useful\r\n* We wanted to learn how to use Web Workers\r\n\r\n### Schedule\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}